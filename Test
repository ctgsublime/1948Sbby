on:
  push:
    paths:
      - '**/*.md'
      - '**/*.html'
  pull_request:
    paths:
      - '**/*.md'
      - '**/*.html'

jobs:
  check-links:
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Detect mismatched URLs vs visual links
        run: |
          python - << 'PY'
          import re
          import sys
          from pathlib import Path
          from urllib.parse import urlparse

          # Treat these as "url-like" visible texts
          URL_TEXT_RE = re.compile(
              r'(?i)^(?:https?://)?[a-z0-9.-]+\.[a-z]{2,}(/.*)?$'
          )

          # Markdown link: [visible](url)
          MD_LINK_RE = re.compile(
              r'\[([^\]]+)\]\(([^)]+)\)'
          )

          # HTML link: <a href="url">visible</a>
          HTML_LINK_RE = re.compile(
              r'<a\s+[^>]*href=["\']([^"\']+)["\'][^>]*>(.*?)</a>',
              re.IGNORECASE | re.DOTALL
          )

          def normalize_host(s: str) -> str:
              if not s:
                  return ""
              if not s.lower().startswith(("http://", "https://")):
                  s = "http://" + s  # dummy scheme
              try:
                  return urlparse(s).hostname or ""
              except Exception:
                  return ""

          def check_pair(visible: str, actual: str, file: Path, line_no: int, problems: list):
              visible = visible.strip()
              actual = actual.strip()

              # Only care if visible text itself looks like a URL
              if not URL_TEXT_RE.match(visible):
                  return

              v_host = normalize_host(visible)
              a_host = normalize_host(actual)

              if v_host and a_host and v_host.lower() != a_host.lower():
                  problems.append(
                      f"{file}:{line_no}: visible link '{visible}' points to '{actual}'"
                  )

          problems = []

          for path in Path(".").rglob("*"):
              if not path.is_file():
                  continue
              if not (path.suffix.lower() in {".md", ".html", ".htm"}):
                  continue

              try:
                  text = path.read_text(encoding="utf-8", errors="ignore")
              except Exception:
                  continue

              # Track line numbers by splitting once
              lines = text.splitlines()
              for i, line in enumerate(lines, start=1):
                  # Markdown links
                  for m in MD_LINK_RE.finditer(line):
                      visible, actual = m.group(1), m.group(2)
                      check_pair(visible, actual, path, i, problems)

              # HTML <a> links (use full text, then map to line number approx)
              for m in HTML_LINK_RE.finditer(text):
                  actual, visible = m.group(1), m.group(2)
                  # approximate line number by counting newlines before match
                  line_no = text.count("\n", 0, m.start()) + 1
                  check_pair(visible, actual, path, line_no, problems)

          if problems:
              print("Found mismatched visual links vs actual URLs:")
              for p in problems:
                  print("  -", p)
              sys.exit(1)
          else:
              print("No mismatched visual links found.")
          PY
